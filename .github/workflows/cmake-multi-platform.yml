name: Build Project with vcpkg (Clang/LLVM, cJSON) - No Ninja - Selective Archive

on:
  push:
    branches: [ "main" ] # Adjust branches as needed
  pull_request:
    branches: [ "main" ] # Adjust branches as needed

env:
  VCPKG_JSON: ".github/workflows/vcpkg.json"
  VCPKG_ROOT: ${{ github.workspace }}/vcpkg
  VCPKG_PACKAGES: "cjson llvm clang"
  EXECUTABLE_NAME: "export" # Define the base executable name

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            vcpkg_triplet: x64-linux
          - os: windows-latest
            vcpkg_triplet: x64-windows
      fail-fast: false

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # 1. Install Base Build Tools (Linux Only)
    - name: Install build dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update -y
        sudo apt-get install -y build-essential cmake git curl zip unzip tar pkg-config

    # 2. Setup vcpkg, Cache, and Install Dependencies
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgDirectory: ${{ env.VCPKG_ROOT }}
        vcpkgJsonGlob: ${{ env.VCPKG_JSON }}
        runVcpkgInstall: false

    - name: Cache vcpkg artifacts
      uses: actions/cache@v4
      id: cache-vcpkg
      with:
        path: ${{ env.VCPKG_ROOT }}
        key: ${{ runner.os }}-${{ matrix.vcpkg_triplet }}-vcpkg-${{ hashFiles(env.VCPKG_PACKAGES) }}
        restore-keys: |
          ${{ runner.os }}-${{ matrix.vcpkg_triplet }}-vcpkg-

    - name: Install vcpkg dependencies
      run: |
        echo "Installing packages: ${{ env.VCPKG_PACKAGES }} for triplet ${{ matrix.vcpkg_triplet }}"
        ${{ env.VCPKG_ROOT }}/vcpkg install ${{ env.VCPKG_PACKAGES }} --triplet ${{ matrix.vcpkg_triplet }}
      shell: bash

    # 3. Configure Project with CMake (Default Generator)
    - name: Configure Project with CMake
      run: |
        # Set compilers
        if [[ "${{ runner.os }}" == "Linux" ]]; then
          export CC="${{ env.VCPKG_ROOT }}/installed/${{ matrix.vcpkg_triplet }}/tools/clang/clang"
          export CXX="${{ env.VCPKG_ROOT }}/installed/${{ matrix.vcpkg_triplet }}/tools/clang/clang++"
        elif [[ "${{ runner.os }}" == "Windows" ]]; then
          CLANG_CL_PATH="${{ env.VCPKG_ROOT }}/installed/${{ matrix.vcpkg_triplet }}/tools/llvm/clang-cl.exe"
          CLANG_CL_PATH_WIN=$(cygpath -w "${CLANG_CL_PATH}")
          export CC="${CLANG_CL_PATH_WIN}"
          export CXX="${CLANG_CL_PATH_WIN}"
        fi
        # Check compilers (omitted for brevity, same as before)

        # Configure CMake
        VCPKG_TOOLCHAIN_FILE="${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake"
        if [[ "${{ runner.os }}" == "Windows" ]]; then
            VCPKG_TOOLCHAIN_FILE=$(cygpath -w "${VCPKG_TOOLCHAIN_FILE}")
        fi

        cmake -S export -B build \
          -DCMAKE_TOOLCHAIN_FILE="${VCPKG_TOOLCHAIN_FILE}" \
          -DVCPKG_TARGET_TRIPLET=${{ matrix.vcpkg_triplet }} \
          -DVCPKG_APPLOCAL_DEPS=ON \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_C_COMPILER="$CC" \
          -DCMAKE_CXX_COMPILER="$CXX"
      shell: bash

    # 4. Build Project
    - name: Build Project
      run: |
        echo "Building project target '${{ env.EXECUTABLE_NAME }}' on ${{ runner.os }}..."
        # Determine cores (omitted for brevity, same as before)
        CORES=$(...) # Replace with previous core detection logic
        echo "Using ${CORES} cores for building..."
        cmake --build build --target ${{ env.EXECUTABLE_NAME }} --config Release --parallel ${CORES}
      shell: bash

    # 5. Package Specific Artifacts (Executable + SO/DLLs)
    - name: Package Artifacts (Linux)
      if: runner.os == 'Linux'
      run: |
        cd build
        echo "Packaging executable and .so files from $(pwd)"
        ls -l # List files for debugging

        # Check if executable exists
        if [[ ! -f "${{ env.EXECUTABLE_NAME }}" ]]; then
          echo "Error: Executable '${{ env.EXECUTABLE_NAME }}' not found in build directory!"
          exit 1
        fi

        # Find .so files in the current directory (build/)
        so_files=$(find . -maxdepth 1 -name '*.so' -print)
        files_to_archive="${{ env.EXECUTABLE_NAME }}"

        if [[ -n "$so_files" ]]; then
          # Add relative paths of .so files (e.g., ./libexample.so)
          relative_so_files=$(echo "$so_files" | sed 's|^\./||') # Remove leading ./ if present
          files_to_archive="$files_to_archive $relative_so_files"
          echo "Found .so files: $relative_so_files"
        else
          echo "No .so files found directly in build directory."
        fi

        echo "Archiving files: $files_to_archive"
        zip ../artifact.zip $files_to_archive
        echo "Created artifact.zip"
        cd ..
      shell: bash

    - name: Package Artifacts (Windows)
      if: runner.os == 'Windows'
      run: |
        $BuildDir = "build/Release" # Default output dir for VS generator Release config
        $ExeName = "${{ env.EXECUTABLE_NAME }}.exe"
        $ExePath = Join-Path $BuildDir $ExeName
        $ArchiveName = "artifact.zip" # Relative path for output zip

        Write-Host "Looking for artifacts in $BuildDir"
        # Check if the presumed output directory exists
        if (-not (Test-Path $BuildDir -PathType Container)) {
          Write-Error "Build output directory not found: $BuildDir"
          # Optional: Try searching directly in 'build' as a fallback
          # $BuildDir = "build"
          # $ExePath = Join-Path $BuildDir $ExeName
          # if (-not (Test-Path $BuildDir -PathType Container)) { exit 1 }
          exit 1
        }

        # Check if executable exists in the target directory
        if (-not (Test-Path $ExePath)) {
            Write-Error "Executable not found at $ExePath"
            Write-Host "Files available in $BuildDir:"
            Get-ChildItem -Path $BuildDir | Select-Object -ExpandProperty Name
            exit 1
        }

        # Find DLLs ONLY in the same directory as the executable
        $DllFiles = Get-ChildItem -Path $BuildDir -Filter *.dll | Select-Object -ExpandProperty Name

        $FilesToArchive = @($ExeName) + $DllFiles

        if ($FilesToArchive.Count -eq 0) {
            Write-Error "No files found to archive (exe or dll) in $BuildDir"
            exit 1
        }

        Write-Host "Archiving the following files from $BuildDir:"
        $FilesToArchive | ForEach-Object { Write-Host "- $_" }

        # Use Push/Pop-Location to simplify paths for Compress-Archive
        Push-Location $BuildDir
        Compress-Archive -Path $FilesToArchive -DestinationPath "../$ArchiveName" -Force
        Pop-Location

        Write-Host "Created $ArchiveName"
      shell: powershell

    # 6. Upload Artifact
    - name: Upload Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: build-artifact-${{ runner.os }}-${{ matrix.vcpkg_triplet }}
        path: artifact.zip # Zipped archive containing exe/dll/so
